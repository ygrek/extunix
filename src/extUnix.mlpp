(** ExtUnix *)

(** [Not_available "func"] may be raised by [ExtUnix.All.func]
    if the wrapped C function is not available on this platform *)
exception Not_available of string

HAVE FSYNC
external fsync : Unix.file_descr -> unit = "caml_extunix_fsync"
END

HAVE FDATASYNC
external fdatasync : Unix.file_descr -> unit = "caml_extunix_fdatasync"
END

HAVE EVENTFD
external eventfd : int -> Unix.file_descr = "caml_extunix_eventfd"
external eventfd_read : Unix.file_descr -> int64 = "caml_extunix_eventfd_read"
external eventfd_write : Unix.file_descr -> int64 -> unit = "caml_extunix_eventfd_write"
END

HAVE DIRFD
external dirfd : Unix.dir_handle -> Unix.file_descr = "caml_extunix_dirfd"
END

HAVE STATVFS
type statvfs = {
  f_bsize : int; (** file system block size *)
  f_blocks : int64; (** size of file system in blocks *)
  f_bfree : int64; (** free blocks *)
  f_bavail : int64; (** free blocks for unprivileged users *)
  f_files : int64; (** inodes *)
  f_ffree : int64; (** free inodes *)
  f_favail : int64; (** free inodes for unprivileged users *)
  f_fsid : int64; (** file system ID *)
  f_flag : int; (** mount flags *)
  f_namemax : int; (** maximum filename length *)
}
external statvfs : string -> statvfs = "caml_extunix_statvfs"
external fstatvfs : Unix.file_descr -> statvfs = "caml_extunix_fstatvfs"
END

HAVE ATFILE
(*
external at_fdcwd : unit -> Unix.file_descr

(** Pseudo file descriptor denoting current directory *)
let at_fdcwd = at_fdcwd ()
*)

type at_flag = AT_EACCESS | AT_SYMLINK_NOFOLLOW | AT_REMOVEDIR | AT_SYMLINK_FOLLOW
external openat : Unix.file_descr -> string -> Unix.open_flag list -> Unix.file_perm -> Unix.file_descr = "caml_extunix_openat"
external fstatat : Unix.file_descr -> string -> Unix.stats = "caml_extunix_fstatat"
(** Supported flags : [AT_REMOVEDIR] *)
external unlinkat : Unix.file_descr -> string -> at_flag list -> unit = "caml_extunix_unlinkat"
external renameat : Unix.file_descr -> string -> Unix.file_descr -> string -> unit = "caml_extunix_renameat"
external mkdirat : Unix.file_descr -> string -> int -> unit = "caml_extunix_mkdirat"
(** Supported flags : [AT_SYMLINK_FOLLOW] *)
external linkat : Unix.file_descr -> string -> Unix.file_descr -> string -> at_flag list -> unit = "caml_extunix_linkat"
external symlinkat : string -> Unix.file_descr -> string -> unit = "caml_extunix_symlinkat"
END

HAVE UNAME

(** uname
    {b Author:} Sylvain Le Gall [sylvain\@le-gall.net]
  *)
module Uname = struct
type t =
    {
      sysname:    string;
      nodename:   string;
      release:    string;
      version:    string;
      machine:    string;
    }

let to_string t =
  String.concat " " [ t.sysname; t.nodename; t.release; t.version; t.machine ]
end

external uname : unit -> Uname.t = "caml_extunix_uname"

END

HAVE FADVISE

(** {2 posix_fadvise}

{b Author:} Sylvain Le Gall *)

type advice =
  | POSIX_FADV_NORMAL     (** Indicates that the application has no advice to
                              give about its access pattern for the specified
                              data.  *)
  | POSIX_FADV_SEQUENTIAL (** The application expects to access the specified
                              data sequentially.  *)
  | POSIX_FADV_RANDOM     (** The specified data will be accessed in random
                              order.  *)
  | POSIX_FADV_NOREUSE    (** The specified data will be accessed only once.  *)
  | POSIX_FADV_WILLNEED   (** The specified data will be accessed in the near
                              future.  *) 
  | POSIX_FADV_DONTNEED   (** The specified data will not be accessed in the
                              near future.  *)

(**/**) (*camlp4 misplaces comments*) (**/**)

external fadvise: Unix.file_descr -> int -> int -> advice -> unit = "caml_extunix_fadvise"

END

HAVE FALLOCATE

(** {2 posix_fallocate} *)
(** Allocate disk space for file

    {b Author:} Sylvain Le Gall
  *)

(** [fallocate fd off len] allocates disk space to ensure that subsequent writes
    between [off] and [off + len] in [fd] will not fail because of lack of disk 
    space. The file size is modified if [off + len] is bigger than the current size.
  *)
external fallocate: Unix.file_descr -> int -> int -> unit = "caml_extunix_fallocate"

END

HAVE PREAD
(** {2 pread}

    {b Author:} Goswin von Brederlow *)

(** [pread fd off buf ofs len] reads up to [len] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the buffer string [buf] at offset [ofs]. The file offset is not
    changed.

    Return the number of characters actually read. [pread] repeats the
    read operation until all characters have been read or an error
    occurs. On error some data may or may not been read.

    On End-of-file the number of characters read is returned including
    but not limited to 0. Non-blocking files raise an Unix_error of
    EAGAIN if no characters could be read. *)
external unsafe_pread: Unix.file_descr -> int -> string -> int -> int -> int = "caml_extunix_pread"

let pread fd off buf ofs len =
  if off < 0 || ofs < 0 || len < 0 || ofs > String.length buf - len
  then invalid_arg "ExtUnix.pread"
  else unsafe_pread fd off buf ofs len

(** [single_pread fd off buf ofs len] - Same as pread, but attempts to
    read only once. Thus, if an error occurs, single_read guarantees
    that no data has been read. Reads at most UNIX_BUFFER_SIZE (16384)
    characters. *)
external unsafe_single_pread: Unix.file_descr -> int -> string -> int -> int -> int = "caml_extunix_single_pread"

let single_pread fd off buf ofs len =
  if off < 0 || ofs < 0 || len < 0 || ofs > String.length buf - len
  then invalid_arg "ExtUnix.single_pread"
  else unsafe_single_pread fd off buf ofs len
END

HAVE PWRITE
(** {2 pwrite}

    {b Author:} Goswin von Brederlow *)

(** [pwrite fd off buf ofs len] writes up to [len] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the buffer string [buf] at offset [ofs]. The file offset is not
    changed.
    
    Return the number of characters actually write. [pwrite] repeats
    the write operation until all characters have been written or an
    error occurs. On error some data may or may not been written.

    Non-blocking files raise an Unix_error of EAGAIN if no characters
    could be written. *)
external unsafe_pwrite: Unix.file_descr -> int -> string -> int -> int -> int = "caml_extunix_pwrite"

let pwrite fd off buf ofs len =
  if off < 0 || ofs < 0 || len < 0 || ofs > String.length buf - len
  then invalid_arg "ExtUnix.pwrite"
  else unsafe_pwrite fd off buf ofs len

(** [single_pwrite fd off buf ofs len] - Same as pwrite, but attempts
    to write only once. Thus, if an error occurs, single_write
    guarantees that no data has been written. Writes at most
    UNIX_BUFFER_SIZE (16384) characters. *)
external unsafe_single_pwrite: Unix.file_descr -> int -> string -> int -> int -> int = "caml_extunix_single_pwrite"

let single_pwrite fd off buf ofs len =
  if off < 0 || ofs < 0 || len < 0 || ofs > String.length buf - len
  then invalid_arg "ExtUnix.single_pwrite"
  else unsafe_single_pwrite fd off buf ofs len
END
    
(** File operations on large files *)
module LargeFile =
struct

  (** File operations on large files. This sub-module provides 64-bit
      variants of the functions ExtUnix.fadvise (for predeclaring an
      access pattern for file data), ExtUnix.fallocate (for allocating
      disk space for a file), ExtUnix.pread, ExtUnix.single_pread,
      ExtUnix.pwrite and ExtUnix.single_pwrite (for reading from or
      writing to a file descriptor at a given offset). These alternate
      functions represent positions and sizes by 64-bit integers (type
      int64) instead of regular integers (type int), thus allowing
      operating on files whose sizes are greater than max_int. *)

  HAVE FADVISE
  external fadvise: Unix.file_descr -> int64 -> int64 -> advice -> unit = "caml_extunix_fadvise64"
  END

  HAVE FALLOCATE
  external fallocate: Unix.file_descr -> int64 -> int64 -> unit = "caml_extunix_fallocate64"
  END

  HAVE PREAD
  external unsafe_pread: Unix.file_descr -> int64 -> string -> int -> int -> int = "caml_extunix_pread64"

  let pread fd off buf ofs len =
    if off < Int64.zero || ofs < 0 || len < 0 || ofs > String.length buf - len
    then invalid_arg "ExtUnix.LargeFile.pread"
    else unsafe_pread fd off buf ofs len

  external unsafe_single_pread: Unix.file_descr -> int64 -> string -> int -> int -> int = "caml_extunix_single_pread64"

  let single_pread fd off buf ofs len =
    if off < Int64.zero || ofs < 0 || len < 0 || ofs > String.length buf - len
    then invalid_arg "ExtUnix.LargeFile.single_pread"
    else unsafe_single_pread fd off buf ofs len
  END

  HAVE PWRITE
  external unsafe_pwrite: Unix.file_descr -> int64 -> string -> int -> int -> int = "caml_extunix_pwrite64"

  let pwrite fd off buf ofs len =
    if off < Int64.zero || ofs < 0 || len < 0 || ofs > String.length buf - len
    then invalid_arg "ExtUnix.LargeFile.pwrite"
    else unsafe_pwrite fd off buf ofs len

  external unsafe_single_pwrite: Unix.file_descr -> int64 -> string -> int -> int -> int = "caml_extunix_single_pwrite64"

  let single_pwrite fd off buf ofs len =
    if off < Int64.zero || ofs < 0 || len < 0 || ofs > String.length buf - len
    then invalid_arg "ExtUnix.LargeFile.single_pwrite"
    else unsafe_single_pwrite fd off buf ofs len
  END
end

(** {2 ioctl} *)

(** Control the underlying device parameters of special files *)
module Ioctl = struct

HAVE SIOCGIFCONF
(** [siocgifconf sock], where [sock] is any socket, e.g. [socket PF_INET SOCK_DGRAM 0]
  @return the list of interfaces and corresponfing addresses *)
external siocgifconf : sock:Unix.file_descr -> (string * string) list = "caml_extunix_ioctl_siocgifconf"
END

HAVE TTY_IOCTL

(** Enable RTS/CTS (hardware) flow control. See CRTSCTS in tcsetattr(3). 
    {b FIXME this is likely to disappear when separate interface for [tcsetattr] and [tcgetattr] gets implemented} *)
external crtscts : Unix.file_descr -> int = "caml_extunix_crtscts"

(** Get the status of modem bits. See TIOCMGET in tty_ioctl(4). *)
external tiocmget : Unix.file_descr -> int = "caml_extunix_ioctl_TIOCMGET"

(** Set the status of modem bits. See TIOCMSET in tty_ioctl(4). *)
external tiocmset : Unix.file_descr -> int -> unit = "caml_extunix_ioctl_TIOCMSET"

(** Clear the indicated modem bits. See TIOCMBIC in tty_ioctl(4). *)
external tiocmbic : Unix.file_descr -> int -> unit = "caml_extunix_ioctl_TIOCMBIC"

(** Set the indicated modem bits. See TIOCMBIS in tty_ioctl(4). *)
external tiocmbis : Unix.file_descr -> int -> unit = "caml_extunix_ioctl_TIOCMBIS"

END

end (* module Ioctl *)

(** {2 Miscellaneous} *)

HAVE TTYNAME
external ttyname : Unix.file_descr -> string = "caml_extunix_ttyname"
END

HAVE CTERMID
(** Get controlling terminal name *)
external ctermid : unit -> string = "caml_extunix_ctermid"
END

HAVE PGID

(** [setpgid pid pgid] sets the process group of the process specified by [pid] to [pgid].
    If [pid] is zero, then the process ID of the calling process is used. If
    [pgid] is zero, then the PGID of the process specified by [pid] is made the same as its process ID. *)
external setpgid : int -> int -> unit = "caml_extunix_setpgid"

(** [getpgid pid] returns the PGID of the process specified by [pid].
    If [pid] is zero, the process ID of the calling process is used. *)
external getpgid : int -> int = "caml_extunix_getpgid"

(** [getsid pid] returns the session ID of the process specified by [pid].
    If [pid] is zero, the process ID of the calling process is used. *)
external getsid : int -> int = "caml_extunix_getsid"

END

HAVE SETREUID

(** [setreuid ruid euid] sets real and effective user IDs of the calling process.
    Supplying a value of -1 for either the real or effective user ID forces the system to leave that ID unchanged. 
    @see "setreuid(2)" manual *)
external setreuid : int -> int -> unit = "caml_extunix_setreuid"

(** [setregid rgid egid] sets real and effective group IDs of the calling process.
    Supplying a value of -1 for either the real or effective group ID forces the system to leave that ID unchanged. 
    @see "setregid(2)" manual *)
external setregid : int -> int -> unit = "caml_extunix_setregid"

END

HAVE REALPATH
(** [realpath path]
    @return the canonicalized absolute pathname of [path]
    @see "realpath(2)" manual *)
external realpath : string -> string = "caml_extunix_realpath"
END

HAVE FCNTL
(** @return whether file desctiptor is open *)
external is_open_descr : Unix.file_descr -> bool = "caml_extunix_is_open_descr"
END

HAVE TCPGRP
external tcgetpgrp : Unix.file_descr -> int = "caml_extunix_tcgetpgrp"
external tcsetpgrp : Unix.file_descr -> int -> unit = "caml_extunix_tcsetpgrp"
END

(** @raise Not_available if OS does not represent file descriptors as numbers *)
let int_of_file_descr : Unix.file_descr -> int =
  if Obj.is_block (Obj.repr Unix.stdin) then
    fun _ -> raise (Not_available "int_of_file_descr")
  else
    Obj.magic

(** @raise Not_available if OS does not represent file descriptors as numbers *)
let file_descr_of_int : int -> Unix.file_descr =
  if Obj.is_block (Obj.repr Unix.stdin) then
    fun _ -> raise (Not_available "file_descr_of_int")
  else
    Obj.magic

HAVE SIGNALFD

(** {2 signalfd} *)

(** OCaml bindings for signalfd(2) and related functions

    {b Author:} Kaustuv Chaudhuri <kaustuv.chaudhuri\@inria.fr>
*)

(******************************************************************************)
(* signalfd bindings                                                          *)
(*                                                                            *)
(* NO COPYRIGHT -- RELEASED INTO THE PUBLIC DOMAIN                            *)
(*                                                                            *)
(* Author: Kaustuv Chaudhuri <kaustuv.chaudhuri@inria.fr>                     *)
(******************************************************************************)

(** [signalfd ?fd sigs flags ()]
    If the first optional argument is omitted, then a new file descriptor is allocated.
    Otherwise, the given file descriptor is modified (in which case it
    must have been created with [signalfd] previously). When you are
    done with the fd, remember to {!Unix.close} it. Do not forget
    to block [sigs] with {!Unix.sigprocmask} to prevent signal handling
    according to default dispositions.
    @see "signalfd(2)" manual
    *)
external signalfd : ?fd:Unix.file_descr -> sigs:int list -> flags:int list -> unit -> Unix.file_descr ="caml_extunix_signalfd"

(** This type represents signal information that is read(2) from the
    signalfd. *)
type ssi

(** Blocking read(2) on a signalfd. Has undefined behaviour on
    non-signalfds. Every successful read consumes a pending signal. *)
external signalfd_read    : Unix.file_descr -> ssi = "caml_extunix_signalfd_read"

(** {6 Functions to query the signal information structure.} *)

(** Get the signal value. This form is compatible with the signal
    values defined in the standard {!Sys} module.

    See signalfd(2) for the details of the remaining functions. Most
    of these integers are actually unsigned. *)
external ssi_signo_sys    : ssi -> int   = "caml_extunix_ssi_signo_sys"

external ssi_signo        : ssi -> int32 = "caml_extunix_ssi_signo"
external ssi_errno        : ssi -> int32 = "caml_extunix_ssi_errno"
external ssi_code         : ssi -> int32 = "caml_extunix_ssi_code"
external ssi_pid          : ssi -> int32 = "caml_extunix_ssi_pid"
external ssi_uid          : ssi -> int32 = "caml_extunix_ssi_uid"
external ssi_fd           : ssi -> Unix.file_descr = "caml_extunix_ssi_fd"
external ssi_tid          : ssi -> int32 = "caml_extunix_ssi_tid"
external ssi_band         : ssi -> int32 = "caml_extunix_ssi_band"
external ssi_overrun      : ssi -> int32 = "caml_extunix_ssi_overrun"
external ssi_trapno       : ssi -> int32 = "caml_extunix_ssi_trapno"
external ssi_status       : ssi -> int32 = "caml_extunix_ssi_status"
external ssi_int          : ssi -> int32 = "caml_extunix_ssi_int"
external ssi_ptr          : ssi -> int64 = "caml_extunix_ssi_ptr"
external ssi_utime        : ssi -> int64 = "caml_extunix_ssi_utime"
external ssi_stime        : ssi -> int64 = "caml_extunix_ssi_stime"
external ssi_addr         : ssi -> int64 = "caml_extunix_ssi_addr"

END

HAVE PTRACE

(** {2 ptrace} *)

external ptrace_traceme : unit -> unit = "caml_extunix_ptrace_traceme"
external ptrace_peekdata : int -> nativeint -> nativeint = "caml_extunix_ptrace_peekdata"
external ptrace_peektext : int -> nativeint -> nativeint = "caml_extunix_ptrace_peektext"

type ptrace_request =
  | PTRACE_ATTACH
  | PTRACE_DETACH

external ptrace : int -> ptrace_request -> unit = "caml_extunix_ptrace"

END

HAVE RESOURCE

(** 
  {2 POSIX resource operations}

  {b Author:} Sylvain Le Gall <sylvain\@le-gall.net>
*)

type which_prio_t =
  | PRIO_PROCESS of int (** Priority for a process id *)
  | PRIO_PGRP of int    (** Priority for a process group id *)
  | PRIO_USER of int    (** Priority for a user id *)

type priority = int

type resource =
  | RLIMIT_CORE   (** Limit on size of core dump file. *)
  | RLIMIT_CPU    (** Limit on CPU time per process. *)
  | RLIMIT_DATA   (** Limit on data segment size. *)
  | RLIMIT_FSIZE  (** Limit on file size. *)
  | RLIMIT_NOFILE (** Limit on number of open files. *)
  | RLIMIT_STACK  (** Limit on stack size. *)
  | RLIMIT_AS     (** Limit on address space size. *)

let string_of_resource = function
  | RLIMIT_CORE   -> "RLIMIT_CORE"
  | RLIMIT_CPU    -> "RLIMIT_CPU"
  | RLIMIT_DATA   -> "RLIMIT_DATA"
  | RLIMIT_FSIZE  -> "RLIMIT_FSIZE"
  | RLIMIT_NOFILE -> "RLIMIT_NOFILE"
  | RLIMIT_STACK  -> "RLIMIT_STACK"
  | RLIMIT_AS     -> "RLIMIT_AS"

(** Limits *)
module Rlimit = struct

  type t = int64 option (** [Some limit] is fixed limit, [None] is RLIM_INFINITY *)

  let string_of_bytes n =
    let sz, acc = List.fold_left (fun (sz, acc) e ->
      let q = Int64.div sz 1024L in
      let r = Int64.rem sz 1024L in
      let acc = if r <> 0L then Printf.sprintf "%Ld %s" r e :: acc else acc in
      (q, acc)) (n, []) ["B"; "KB"; "MB"; "GB"] 
    in
    let acc = if sz <> 0L then Printf.sprintf "%Ld TB" sz :: acc else acc in
    match acc with
    | [] -> "0 B"
    | _ -> String.concat " " acc

  let to_string ?r = function
  | None -> "infinity"
  | Some l ->
    match r with 
    | None -> Int64.to_string l
    | Some RLIMIT_CORE
    | Some RLIMIT_DATA 
    | Some RLIMIT_FSIZE
    | Some RLIMIT_STACK
    | Some RLIMIT_AS -> string_of_bytes l
    | Some RLIMIT_NOFILE -> Int64.to_string l
    | Some RLIMIT_CPU -> Printf.sprintf "%Ld s" l

  let compare l1 l2 =
    match l1, l2 with
    | Some l1, Some l2 -> Int64.compare l1 l2
    | None, None -> 0
    | Some _, None -> -1
    | None, Some _ -> 1

  let eq l1 l2 = compare l1 l2 = 0
  let gt l1 l2 = compare l1 l2 > 0
  let ge l1 l2 = compare l1 l2 >= 0
  let lt l1 l2 = compare l1 l2 < 0
  let le l1 l2 = compare l1 l2 <= 0

end (* Rlimit *)

(** Get nice value *)
external getpriority : which_prio_t -> priority = "caml_extunix_getpriority" 

(** Set nice value *)
external setpriority : which_prio_t -> priority -> unit = "caml_extunix_setpriority"

(** Get maximum resource consumption. @return [(soft,hard)] limits *)
external getrlimit : resource -> Rlimit.t * Rlimit.t = "caml_extunix_getrlimit"

(** Set maximum resource consumption *)
external setrlimit : resource -> soft:Rlimit.t -> hard:Rlimit.t -> unit = "caml_extunix_setrlimit"

(* let unlimit_soft r = let (_,hard) = getrlimit r in setrlimit r ~soft:hard ~hard *)

(** [getrusage] is not implemented because the only meaningful information it
    provides are [ru_utime] and [ru_stime] which can be accessed through 
    [Unix.times].
  *)

END

(** Exit process without running any [at_exit] hooks (implemented in Pervasives) *)
external sys_exit : int -> 'a = "caml_sys_exit"

HAVE MLOCKALL
(**  {2 Memory management} *)

type mlockall_flag = MCL_CURRENT | MCL_FUTURE

(** Lock all pages mapped into the address space of the calling process. *)
external mlockall : mlockall_flag list -> unit = "caml_extunix_mlockall"

(** Unlock all pages mapped into the address space of the calling process. *)
external munlockall : unit -> unit = "caml_extunix_munlockall"

END

(** {2 Time conversion} *)

HAVE STRTIME

(** This function is the converse of the {!strftime} function.
  [strptime fmt data] convert a string containing time information [data]
  into a [tm] struct according to the format specified by [fmt]. *)
external strptime: string -> string -> Unix.tm = "caml_extunix_strptime"

(** Return the ascii representation of a given [tm] argument. The
  ascii time is returned in the form of a string like 
  'Wed Jun 30, 21:21:21 2005\n' *)
external asctime: Unix.tm -> string = "caml_extunix_asctime"

(** This functions is the converse of the {!strptime} function.
  [strftime fmt data] convert a a [tm] structure [data] into a string
  according to the format specified by [fmt]. *)
external strftime: string -> Unix.tm -> string = "caml_extunix_strftime"

(** [tzname isdst] 
  @param isdst specifies whether daylight saving is in effect
  @return abbreviated name of the current timezone
*)
external tzname : bool -> string = "caml_extunix_tzname"

END

HAVE TIMEGM

(** Inverse of [Unix.gmtime] *)
external timegm : Unix.tm -> float = "caml_extunix_timegm"

END

HAVE PTS

(** 
  {2 Pseudo terminal management}

  {b Author:} Niki Yoshiuchi <aplusbi\@gmail.com> 
*)

(** This function opens a pseudo-terminal device. *)
external posix_openpt : Unix.open_flag list -> 
  Unix.file_descr = "caml_extunix_posix_openpt"

(** This function grants access to the slave pseudo-terminal. *)
external grantpt: Unix.file_descr -> unit = "caml_extunix_grantpt"

(** This function unlock a pseudo-terminal master/slave pair. *)
external unlockpt: Unix.file_descr -> unit = "caml_extunix_unlockpt"

(** This function get the name of the slave pseudo-terminal. *)
external ptsname: Unix.file_descr -> string = "caml_extunix_ptsname"

END

(** {2 Application self-debugging and diagnostics} *)

HAVE EXECINFO

(** @return a backtrace for the calling program *)
external backtrace : unit -> string array = "caml_extunix_backtrace"

END

HAVE MALLOC_STATS

(** Print brief heap summary statistics on stderr *)
external malloc_stats : unit -> unit = "caml_extunix_malloc_stats"

END

HAVE MALLOC_INFO

(** @return the information about state of allocator *)
external malloc_info : unit -> string = "caml_extunix_malloc_info"

END

HAVE SETENV

(** {2 Environment manipulation} *)

(** [setenv name value overwrite] adds the variable [name] to the environment with the value [value], if [name]
does not already exist or [overwrite] is true *)
external setenv : string -> string -> bool -> unit = "caml_extunix_setenv"

(** [unsetenv name] removes variable [name] from the environment. If [name] does not exist in the environment, then the function
succeeds, and the environment is unchanged. *)
external unsetenv : string -> unit = "caml_extunix_unsetenv"

END

HAVE CLEARENV

(** Clear the environment of all name-value pairs *)
external clearenv : unit -> unit = "caml_extunix_clearenv"

END

HAVE MKDTEMP

(** [mkdtemp template] creates a unique temporary directory (with permissions 0700).
  Last six characters of [template] must be "XXXXXX". *)
external mkdtemp : string -> string = "caml_extunix_mkdtemp"

END

module EndianBig = struct

HAVE ENDIAN
  (** {2 big endian functions}

      {b Author:} Goswin von Brederlow *)

  (** Conversion functions from host to big endian byte order and back *)

  (** Conversion of 16bit integers *)
  (** [uint16_from_host u16] converts an unsigned 16bit integer from host to
      big endian byte order *)
  external uint16_from_host : int -> int = "caml_extunix_htobe16"

  (** [int16_from_host i16] converts a signed 16bit integer from host to
      big endian byte order *)
  external int16_from_host : int -> int = "caml_extunix_htobe16_signed"

  (** [uint16_to_host u16] converts an unsigned 16bit integer from big
      endian to host byte order *)
  external uint16_to_host : int -> int = "caml_extunix_be16toh"

  (** [int16_to_host i16] converts a signed 16bit integer from big
      endian to host byte order *)
  external int16_to_host : int -> int = "caml_extunix_be16toh_signed"

  (** Conversion of 31bit integeres
      On 64bit platforms this actualy converts 32bit integers without
      the need to allocate a new int32. On 32bit platforms it produces
      garbage. For use on 64bit platforms only! *)
  (** [uint31_from_host u31] converts an unsigned 31bit integer from
      host to big endian byte order *)
  external uint31_from_host : int -> int = "caml_extunix_htobe31"

  (** [int31_from_host i31] converts a signed 31bit integer from host to
      big endian byte order *)
  external int31_from_host : int -> int = "caml_extunix_htobe31_signed"

  (** [uint31_to_host u31] converts an unsigned 31bit integer from big
      endian to host byte order *)
  external uint31_to_host : int -> int = "caml_extunix_be31toh"

  (** [int31_to_host i31] converts a signed 31bit integer from big
      endian to host byte order *)
  external int31_to_host : int -> int = "caml_extunix_be31toh_signed"

  (** Conversion of 32bit integers *)
  (** [int32_from_host int32] converts a 32bit integer from host to big
      endian byte order *)
  external int32_from_host : int32 -> int32 = "caml_extunix_htobe32"

  (** [int32_to_host int32] converts a 32bit integer from big endian to
      host byte order *)
  external int32_to_host : int32 -> int32 = "caml_extunix_be32toh"

  (** Conversion of 64bit integers *)
  (** [int64_from_host int64] converts a 64bit integer from host to big
      endian byte order *)
  external int64_from_host : int64 -> int64 = "caml_extunix_htobe64"

  (** [int64_to_host int64] converts a 64bit integer from big endian to
      host byte order *)
  external int64_to_host : int64 -> int64 = "caml_extunix_be64toh"

  (** [unsafe_get_X str off] extract integer of type [X] from string
      [str] starting at offset [off]. Unsigned types are 0 extended
      and signed types are sign extended to fill the ocaml type.
      Bounds checking is not performed. Use with caution and only when
      the program logic guarantees that the access is within bounds.

      Note: The 31bit functions extract a 32bit integer and return it
      as ocaml int. On 32bit platforms this can overflow as ocaml
      integers are 31bit signed there. No error is reported if this
      occurs. Use with care. *)
  external unsafe_get_uint8  : string -> int -> int = "caml_extunix_get_u8"
  external unsafe_get_int8   : string -> int -> int = "caml_extunix_get_s8"
  external unsafe_get_uint16 : string -> int -> int = "caml_extunix_get_bu16"
  external unsafe_get_int16  : string -> int -> int = "caml_extunix_get_bs16"
  external unsafe_get_uint31 : string -> int -> int = "caml_extunix_get_bu31"
  external unsafe_get_int31  : string -> int -> int = "caml_extunix_get_bs31"
  external unsafe_get_int32  : string -> int -> int32 = "caml_extunix_get_bs32"
  external unsafe_get_int64  : string -> int -> int64 = "caml_extunix_get_bs64"

  (** [get_X str off] same as [unsafe_get_X] but with bounds checking. *)
  let get_uint8 str off =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint8 str off

  let get_int8 str off =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int8 str off

  let get_uint16 str off =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint16 str off

  let get_int16 str off =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int16 str off

  let get_uint31 str off =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint31 str off

  let get_int31 str off =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int31 str off

  let get_int32 str off =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int32 str off

  let get_int64 str off =
    if off < 0 || off > String.length str - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int64 str off

  (** [unsafe_set_X str off v] stores the integer [v] as type [X] in
      string [str] starting at offset [off]. Bounds checking is not
      performed. Use with caution and only when the program logic
      guarantees that the access is within bounds.

      Note: The 31bit functions store an ocaml int as 32bit
      integer. On 32bit platforms ocaml integers are 31bit signed and
      will be sign extended to 32bit first. Use with care. *)
  external unsafe_set_uint8  : string -> int -> int -> unit = "caml_extunix_set_8"
  external unsafe_set_int8   : string -> int -> int -> unit = "caml_extunix_set_8"
  external unsafe_set_uint16 : string -> int -> int -> unit = "caml_extunix_set_b16"
  external unsafe_set_int16  : string -> int -> int -> unit = "caml_extunix_set_b16"
  external unsafe_set_uint31 : string -> int -> int -> unit = "caml_extunix_set_b31"
  external unsafe_set_int31  : string -> int -> int -> unit = "caml_extunix_set_b31"
  external unsafe_set_int32  : string -> int -> int32 -> unit = "caml_extunix_set_b32"
  external unsafe_set_int64  : string -> int -> int64 -> unit = "caml_extunix_set_b64"

  (** [set_X str off v] same as [unsafe_set_X] but with bounds checking. *)
  let set_uint8 str off v =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint8 str off v

  let set_int8 str off v =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int8 str off v

  let set_uint16 str off v =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint16 str off v

  let set_int16 str off v =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int16 str off v

  let set_uint31 str off v =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint31 str off v

  let set_int31 str off v =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int31 str off v

  let set_int32 str off v =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int32 str off v

  let set_int64 str off v =
    if off < 0 || off > String.length str - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int64 str off v

END

end

module EndianLittle = struct

HAVE ENDIAN
  (** {2 little endian functions}

      {b Author:} Goswin von Brederlow *)

  (** Conversion functions from host to little endian byte order and back *)

  (** Conversion of 16bit integers *)
  (** [uint16_from_host u16] converts an unsigned 16bit integer from host to
      little endian byte order *)
  external uint16_from_host : int -> int = "caml_extunix_htole16"

  (** [int16_from_host i16] converts a signed 16bit integer from host to
      little endian byte order *)
  external int16_from_host : int -> int = "caml_extunix_htole16_signed"

  (** [uint16_to_host u16] converts an unsigned 16bit integer from little
      endian to host byte order *)
  external uint16_to_host : int -> int = "caml_extunix_le16toh"

  (** [int16_to_host i16] converts a signed 16bit integer from little
      endian to host byte order *)
  external int16_to_host : int -> int = "caml_extunix_le16toh_signed"

  (** Conversion of 31bit integeres
      On 64bit platforms this actualy converts 32bit integers without
      the need to allocate a new int32. On 32bit platforms it produces
      garbage. For use on 64bit platforms only! *)
  (** [uint31_from_host u31] converts an unsigned 31bit integer from
      host to little endian byte order *)
  external uint31_from_host : int -> int = "caml_extunix_htole31"

  (** [int31_from_host i31] converts a signed 31bit integer from host to
      little endian byte order *)
  external int31_from_host : int -> int = "caml_extunix_htole31_signed"

  (** [uint31_to_host u31] converts an unsigned 31bit integer from little
      endian to host byte order *)
  external uint31_to_host : int -> int = "caml_extunix_le31toh"

  (** [int31_to_host i31] converts a signed 31bit integer from little
      endian to host byte order *)
  external int31_to_host : int -> int = "caml_extunix_le31toh_signed"

  (** Conversion of 32bit integers *)
  (** [int32_from_host int32] converts a 32bit integer from host to little
      endian byte order *)
  external int32_from_host : int32 -> int32 = "caml_extunix_htole32"

  (** [int32_to_host int32] converts a 32bit integer from little endian to
      host byte order *)
  external int32_to_host : int32 -> int32 = "caml_extunix_le32toh"

  (** Conversion of 64bit integers *)
  (** [int64_from_host int64] converts a 64bit integer from host to little
      endian byte order *)
  external int64_from_host : int64 -> int64 = "caml_extunix_htole64"

  (** [int64_to_host int64] converts a 64bit integer from little endian to
      host byte order *)
  external int64_to_host : int64 -> int64 = "caml_extunix_le64toh"
  
  (** [unsafe_get_X str off] extract integer of type [X] from string
      [str] starting at offset [off]. Unsigned types are 0 extended
      and signed types are sign extended to fill the ocaml type.
      Bounds checking is not performed. Use with caution and only when
      the program logic guarantees that the access is within bounds.

      Note: The 31bit functions extract a 32bit integer and return it
      as ocaml int. On 32bit platforms this can overflow as ocaml
      integers are 31bit signed there. No error is reported if this
      occurs. Use with care. *)
  external unsafe_get_uint8  : string -> int -> int = "caml_extunix_get_u8"
  external unsafe_get_int8   : string -> int -> int = "caml_extunix_get_s8"
  external unsafe_get_uint16 : string -> int -> int = "caml_extunix_get_lu16"
  external unsafe_get_int16  : string -> int -> int = "caml_extunix_get_ls16"
  external unsafe_get_uint31 : string -> int -> int = "caml_extunix_get_lu31"
  external unsafe_get_int31  : string -> int -> int = "caml_extunix_get_ls31"
  external unsafe_get_int32  : string -> int -> int32 = "caml_extunix_get_ls32"
  external unsafe_get_int64  : string -> int -> int64 = "caml_extunix_get_ls64"

  (** [get_X str off] same as [unsafe_get_X] but with bounds checking. *)
  let get_uint8 str off =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint8 str off

  let get_int8 str off =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int8 str off

  let get_uint16 str off =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint16 str off

  let get_int16 str off =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int16 str off

  let get_uint31 str off =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint31 str off

  let get_int31 str off =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int31 str off

  let get_int32 str off =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int32 str off

  let get_int64 str off =
    if off < 0 || off > String.length str - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int64 str off

  (** [unsafe_set_X str off v] stores the integer [v] as type [X] in
      string [str] starting at offset [off]. Bounds checking is not
      performed. Use with caution and only when the program logic
      guarantees that the access is within bounds.

      Note: The 31bit functions store an ocaml int as 32bit
      integer. On 32bit platforms ocaml integers are 31bit signed and
      will be sign extended to 32bit first. Use with care. *)
  external unsafe_set_uint8  : string -> int -> int -> unit = "caml_extunix_set_8"
  external unsafe_set_int8   : string -> int -> int -> unit = "caml_extunix_set_8"
  external unsafe_set_uint16 : string -> int -> int -> unit = "caml_extunix_set_l16"
  external unsafe_set_int16  : string -> int -> int -> unit = "caml_extunix_set_l16"
  external unsafe_set_uint31 : string -> int -> int -> unit = "caml_extunix_set_l31"
  external unsafe_set_int31  : string -> int -> int -> unit = "caml_extunix_set_l31"
  external unsafe_set_int32  : string -> int -> int32 -> unit = "caml_extunix_set_l32"
  external unsafe_set_int64  : string -> int -> int64 -> unit = "caml_extunix_set_l64"

  (** [set_X str off v] same as [unsafe_set_X] but with bounds checking. *)
  let set_uint8 str off v =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint8 str off v

  let set_int8 str off v =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int8 str off v

  let set_uint16 str off v =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint16 str off v

  let set_int16 str off v =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int16 str off v

  let set_uint31 str off v =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint31 str off v

  let set_int31 str off v =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int31 str off v

  let set_int32 str off v =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int32 str off v

  let set_int64 str off v =
    if off < 0 || off > String.length str - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int64 str off v

END

end

module EndianNet = EndianBig

module EndianHost = struct

  (** {2 host endian functions}

      {b Author:} Goswin von Brederlow *)

  (** [unsafe_get_X str off] extract integer of type [X] from string
      [str] starting at offset [off]. Unsigned types are 0 extended
      and signed types are sign extended to fill the ocaml type.
      Bounds checking is not performed. Use with caution and only when
      the program logic guarantees that the access is within bounds.

      Note: The 31bit functions extract a 32bit integer and return it
      as ocaml int. On 32bit platforms this can overflow as ocaml
      integers are 31bit signed there. No error is reported if this
      occurs. Use with care. *)
  external unsafe_get_uint8  : string -> int -> int = "caml_extunix_get_u8"
  external unsafe_get_int8   : string -> int -> int = "caml_extunix_get_s8"
  external unsafe_get_uint16 : string -> int -> int = "caml_extunix_get_hu16"
  external unsafe_get_int16  : string -> int -> int = "caml_extunix_get_hs16"
  external unsafe_get_uint31 : string -> int -> int = "caml_extunix_get_hu31"
  external unsafe_get_int31  : string -> int -> int = "caml_extunix_get_hs31"
  external unsafe_get_int32  : string -> int -> int32 = "caml_extunix_get_hs32"
  external unsafe_get_int64  : string -> int -> int64 = "caml_extunix_get_hs64"

  (** [get_X str off] same as [unsafe_get_X] but with bounds checking. *)
  let get_uint8 str off =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint8 str off

  let get_int8 str off =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int8 str off

  let get_uint16 str off =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint16 str off

  let get_int16 str off =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int16 str off

  let get_uint31 str off =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint31 str off

  let get_int31 str off =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int31 str off

  let get_int32 str off =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int32 str off

  let get_int64 str off =
    if off < 0 || off > String.length str - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int64 str off

  (** [unsafe_set_X str off v] stores the integer [v] as type [X] in
      string [str] starting at offset [off]. Bounds checking is not
      performed. Use with caution and only when the program logic
      guarantees that the access is within bounds.

      Note: The 31bit functions store an ocaml int as 32bit
      integer. On 32bit platforms ocaml integers are 31bit signed and
      will be sign extended to 32bit first. Use with care. *)
  external unsafe_set_uint8  : string -> int -> int -> unit = "caml_extunix_set_8"
  external unsafe_set_int8   : string -> int -> int -> unit = "caml_extunix_set_8"
  external unsafe_set_uint16 : string -> int -> int -> unit = "caml_extunix_set_h16"
  external unsafe_set_int16  : string -> int -> int -> unit = "caml_extunix_set_h16"
  external unsafe_set_uint31 : string -> int -> int -> unit = "caml_extunix_set_h31"
  external unsafe_set_int31  : string -> int -> int -> unit = "caml_extunix_set_h31"
  external unsafe_set_int32  : string -> int -> int32 -> unit = "caml_extunix_set_h32"
  external unsafe_set_int64  : string -> int -> int64 -> unit = "caml_extunix_set_h64"

  (** [set_X str off v] same as [unsafe_set_X] but with bounds checking. *)
  let set_uint8 str off v =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint8 str off v

  let set_int8 str off v =
    if off < 0 || off >= String.length str
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int8 str off v

  let set_uint16 str off v =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint16 str off v

  let set_int16 str off v =
    if off < 0 || off > String.length str - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int16 str off v

  let set_uint31 str off v =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint31 str off v

  let set_int31 str off v =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int31 str off v

  let set_int32 str off v =
    if off < 0 || off > String.length str - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int32 str off v

  let set_int64 str off v =
    if off < 0 || off > String.length str - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int64 str off v

end

HAVE READ_CREDENTIALS

(** {2 read_credentials }

      {b Author:} Andre Nathan *)

(** Reads sender credentials from a file descriptor, returning a 3-element
    tuple containing the sender process' PID, UID and GID. *)
external read_credentials : Unix.file_descr -> int * int * int = "caml_extunix_read_credentials"

END

HAVE FEXECVE

(** {2 fexecve }

    {b Author:} Andre Nathan *)

(** [fexecve fd args env] executes the program in file represented by
    file descriptor [fd] with arguments [args] and environment
    variables given by [env]. As with the [execv*] functions, on
    success [fexecve] never returns; the current process is replaced
    by the new one.
*)
external fexecve: Unix.file_descr -> string array -> string array -> 'a = "caml_extunix_fexecve"

  END

HAVE SENDMSG

(** {2 sendmsg / readmsg }

    {b Author:} Andre Nathan *)

(** Send a message and optionally a file descriptor through a socket. Passing
    file descriptors requires UNIX domain sockets. *)
external sendmsg: Unix.file_descr -> ?sendfd:Unix.file_descr -> string -> unit = "caml_extunix_sendmsg"

(** Recieve a message and possibly a file descriptor from a socket.  *)
external recvmsg_fd: Unix.file_descr -> (Unix.file_descr option) * string = "caml_extunix_recvmsg"

(** Send a file descriptor through a UNIX domain socket. *)
let sendfd conn_fd fd_to_send =
  sendmsg conn_fd ~sendfd:fd_to_send ""

(** Receive a file descriptor sent through a UNIX domain socket. *)
let recvfd fd =
  match recvmsg_fd fd with
  | (Some recvfd, _) -> recvfd
  | _ -> raise (Unix.Unix_error (Unix.EINVAL, "recvfd", "no descriptor"))

(** Receive a message sent through a UNIX domain socket. Raises
    Recvfd(fd, msg) if a file descriptor is recieved. *)
exception Recvfd of Unix.file_descr * string
let recvmsg fd =
  match recvmsg_fd fd with
  | (None, msg) -> msg
  | (Some fd, msg) -> raise (Recvfd (fd, msg))

(** Receive a message sent through a UNIX domain socket. Closes and
    ignores file descriptors. *)
let recvmsg_nofd fd =
  match recvmsg_fd fd with
  | (Some fd, msg) -> Unix.close fd; msg
  | (None, msg) -> msg

END

(* NB Should be after all 'external' definitions *)

(** {2 Meta} *)
(** [have name]
  @return indication whether function [name] is available
  - [Some true] if available
  - [Some false] if not available
  - [None] if not known

  e.g. [have "eventfd"]
*)
SHOW ME THE MONEY

